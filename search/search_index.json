{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Documentaci\u00f3n del Proyecto","text":"<p>Bienvenido \ud83d\udc4b Esta es una plantilla basada en MkDocs + Material for MkDocs para cursos y proyectos.</p>"},{"location":"#empezar-rapido-3-pasos","title":"Empezar r\u00e1pido (3 pasos)","text":"<ol> <li>Edita el nombre del sitio en <code>mkdocs.yml</code>:    ```yaml    site_name: Documentaci\u00f3n del Curso    theme:      name: material</li> </ol>"},{"location":"comandos/","title":"Encabezados EMMANUEL hhh","text":"<pre><code># T\u00edtulo H1\n## T\u00edtulo H2\n### T\u00edtulo H3\n</code></pre>"},{"location":"comandos/#titulo-h1-fff","title":"T\u00edtulo H1 FFF","text":""},{"location":"comandos/#titulo-h2","title":"T\u00edtulo H2","text":""},{"location":"comandos/#titulo-h3","title":"T\u00edtulo H3","text":""},{"location":"comandos/#enfasis-y-codigo-en-linea","title":"\u00c9nfasis y c\u00f3digo en l\u00ednea","text":"<pre><code>**negritas**, *cursivas*, ~~tachado~~, `c\u00f3digo en l\u00ednea`\n</code></pre> <p>negritas, cursivas, ~~tachado~~, <code>c\u00f3digo en l\u00ednea</code></p>"},{"location":"comandos/#citas-blockquote","title":"Citas (blockquote)","text":"<pre><code>&gt; Esta es una cita destacada.\n&gt; Puede tener m\u00faltiples l\u00edneas.\n</code></pre> <p>Esta es una cita destacada. Puede tener m\u00faltiples l\u00edneas.</p>"},{"location":"comandos/#enlaces","title":"Enlaces","text":"<pre><code>[Enlace directo](https://www.iberopuebla.mx/)\n\n[Texto del enlace de referencia][doc-ref]\n\n[doc-ref]: https://www.iberopuebla.mx//docs \"T\u00edtulo opcional\"\n</code></pre> <p>Enlace directo</p> <p>Texto del enlace de referencia</p>"},{"location":"comandos/#listas-vinetas-numeradas-y-de-tareas","title":"Listas: vi\u00f1etas, numeradas y de tareas","text":"<pre><code>- Item A\n    * Subitem A.1\n    * Subitem A.2\n- Item B\n    - Subitem B.1\n    - Subitem B.2\n\n1.  Paso 1\n    1.  Paso 1.1\n    2.  Paso 1.2\n        1.  Paso 1.2.1\n        2.  Paso 1.2.2\n\n- [x] Hecho\n- [ ] Pendiente\n</code></pre> <ul> <li>Item A<ul> <li>Subitem A.1</li> <li>Subitem A.2</li> </ul> </li> <li>Item B<ul> <li>Subitem B.1</li> <li>Subitem B.2</li> </ul> </li> </ul> <ol> <li> <p>Paso 1</p> <ol> <li>Paso 1.1</li> <li>Paso 1.2<ol> <li>Paso 1.2.1</li> <li>Paso 1.2.2</li> </ol> </li> </ol> </li> <li> <p> Hecho</p> </li> <li> Pendiente</li> </ol>"},{"location":"comandos/#tablas","title":"Tablas","text":"<pre><code>| Componente | Cant. | Nota        |\n|-----------:|:-----:|-------------|\n| Sensor X   | 2     | I2C         |\n| MCU Y      | 1     | WiFi/BLE    |\n</code></pre> Componente Cant. Nota Sensor X 2 I2C MCU Y 1 WiFi/BLE"},{"location":"comandos/#imagenes","title":"Im\u00e1genes","text":"<pre><code>![Diagrama del sistema](recursos/imgs/ibero.jpeg)\n\n&lt;!-- Control de tama\u00f1o usando HTML (cuando se requiera) --&gt;\n&lt;img src=\"../recursos/imgs/ibero.jpeg\" alt=\"Diagrama del sistema\" width=\"420\"&gt;\n</code></pre>"},{"location":"comandos/#pdfs-enlace-y-embebido","title":"PDFs (enlace y embebido)","text":"<pre><code>[Descargar especificaci\u00f3n (PDF)](recursos/archivos/Calendario.pdf)\n\n&lt;!-- Embed (requiere navegador compatible) --&gt;\n&lt;object data=\"recursos/archivos/Calendario.pdf\" type=\"application/pdf\" width=\"100%\" height=\"600\"&gt;\n  &lt;p&gt;No se pudo mostrar el PDF. &lt;a href=\"../recursos/archivos/Calendario.pdf\"&gt;Descargar&lt;/a&gt;&lt;/p&gt;\n&lt;/object&gt;\n</code></pre> <p>Descargar especificaci\u00f3n (PDF)</p>"},{"location":"comandos/#admonitions-material","title":"Admonitions (Material)","text":"<pre><code>!!! note \"Nota\"\n    Esto es una nota informativa.\n\n!!! tip \"Sugerencia\"\n    Un consejo breve para el usuario.\n\n!!! warning \"Advertencia\"\n    Precauciones o riesgos a considerar.\n\n??? info \"M\u00e1s informaci\u00f3n (colapsable)\"\n    Contenido adicional que se puede expandir.\n</code></pre> <p>Nota</p> <p>Esto es una nota informativa.</p> <p>Sugerencia</p> <p>Un consejo breve para el usuario.</p> <p>Advertencia</p> <p>Precauciones o riesgos a considerar.</p> M\u00e1s informaci\u00f3n (colapsable) <p>Contenido adicional que se puede expandir.</p>"},{"location":"comandos/#codigo-con-resaltado","title":"C\u00f3digo con resaltado","text":"<p><pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre> <pre><code>```python\ndef medir(canal: int) -&gt; dict:\n    # Simulaci\u00f3n de lectura\n    return {\"canal\": canal, \"valor\": 523, \"unidad\": \"mV\"}\n\nprint(medir(1))\n</code></pre></p>"},{"location":"comandos/#separador-horizontal","title":"Separador horizontal","text":"<pre><code>---\n</code></pre>"},{"location":"comandos/#listas-anidadas-con-codigo-y-notas","title":"Listas anidadas con c\u00f3digo y notas","text":"<pre><code>- **M\u00f3dulo A**\n  - Funci\u00f3n: `procesar()`\n  - Entrada:\n    - `signal` (float)\n    - `freq` (Hz)\n  - Salida:\n    - JSON con `valor`, `unidad`\n  - !!! note\n        Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> <ul> <li>M\u00f3dulo A</li> <li>Funci\u00f3n: <code>procesar()</code></li> <li>Entrada:<ul> <li><code>signal</code> (float)</li> <li><code>freq</code> (Hz)</li> </ul> </li> <li>Salida:<ul> <li>JSON con <code>valor</code>, <code>unidad</code></li> </ul> </li> <li> <p>Note</p> <pre><code>Documenta rangos v\u00e1lidos y casos borde.\n</code></pre> </li> </ul>"},{"location":"comandos/#bloques-de-cita-con-codigo-pseudo-logs","title":"Bloques de cita con c\u00f3digo (pseudo-logs)","text":"<pre><code>&gt; **Log:**\n&gt; ```\n&gt; [12:00:00] Init OK\n&gt; [12:00:01] Conectando a I2C...\n&gt; [12:00:02] Lectura: 523 mV\n&gt; ```\n</code></pre> <p>Log: <pre><code>[12:00:00] Init OK\n[12:00:01] Conectando a I2C...\n[12:00:02] Lectura: 523 mV\n</code></pre></p>"},{"location":"ejemplo/","title":"\ud83d\udcda DOCUMENTACI\u00d3N ELEMENTOS PROGRAMABLES II","text":""},{"location":"ejemplo/#departamento-de-ciencias-e-ingenieria-universidad-iberoamericana-puebla-mexico","title":"Departamento de Ciencias e Ingenier\u00eda | Universidad Iberoamericana Puebla, M\u00e9xico","text":"<p>En esta p\u00e1gina se documentara cada proceso de aprendizaje durante la clase de Elementos Programables II </p>"},{"location":"ejemplo/#1-resumen","title":"1) Resumen","text":"<ul> <li>Nombre del proyecto: Mi Proyecto </li> <li>Equipo / Autor(es): Nombre(s) </li> <li>Curso / Asignatura: Nombre del curso </li> <li>Fecha: DD/MM/AAAA </li> <li>Descripci\u00f3n breve: Una o dos l\u00edneas que expliquen qu\u00e9 hace y por qu\u00e9.</li> </ul> <p>Consejo</p> <p>Mant\u00e9n este resumen corto (m\u00e1x. 5 l\u00edneas). Lo dem\u00e1s va en secciones espec\u00edficas.</p>"},{"location":"ejemplo/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Qu\u00e9 se pretende lograr en t\u00e9rminos amplios.</li> <li>Espec\u00edficos:</li> <li>OE1\u2026</li> <li>OE2\u2026</li> <li>OE3\u2026</li> </ul>"},{"location":"ejemplo/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Qu\u00e9 funcionalidades/entregables s\u00ed est\u00e1n en el proyecto.</li> <li>No incluye: Qu\u00e9 queda fuera para evitar malentendidos.</li> </ul>"},{"location":"ejemplo/#4-requisitos","title":"4) Requisitos","text":"<p>Software - SO compatible (Windows/Linux/macOS) - Python 3.x / Node 18+ / Arduino IDE / etc. - Dependencias (p. ej., pip/requirements, npm packages)</p> <p>Hardware (si aplica) - MCU / Sensores / Actuadores / Fuente de poder - Herramientas (mult\u00edmetro, caut\u00edn, etc.)</p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en X - Electr\u00f3nica b\u00e1sica - Git/GitHub</p>"},{"location":"ejemplo/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># 1) Clonar\ngit clone https://github.com/&lt;usuario&gt;/&lt;repo&gt;.git\ncd &lt;repo&gt;\n\n# 2) (Opcional) Crear entorno virtual\npython -m venv .venv\n# macOS/Linux\nsource .venv/bin/activate\n# Windows (PowerShell)\n.venv\\Scripts\\Activate.ps1\n\n# 3) Instalar dependencias (ejemplos)\npip install -r requirements.txt\n# o, si es Node:\nnpm install\n</code></pre>"},{"location":"practica1/","title":"\ud83d\udcda Pr\u00e1ctica 1 - NeoPixel_B\u00e1sico","text":"<p>El programa crea un efecto de parpedeo infinito de algun color que sepamos su \"rgb\", donde las personas no alcanzamos a distinguir. Ocupamos conceptos b\u00e1sicos de control de  LEDs RGB y temporizaci\u00f3n con delays. Es ideal si no comprendes el funcionamiento de los NeoPixels. </p>"},{"location":"practica1/#1-resumen","title":"1) Resum\u00e9n \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): ANGELES BARRETO EMMANUEL, CEREZO PONCE JESUS ALFREDO</li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 25/08/25  </li> </ul>"},{"location":"practica1/#2-codigo","title":"2) C\u00f3digo \u2328\ufe0f","text":"<pre><code># ========================================\n #LIBRER\u00cdAS NECESARIAS\n# ========================================\n #Desde el primer include hasta el \"define\" llevan #\ninclude &lt;Adafruit_NeoPixel.h&gt;  // Librer\u00eda para controlar LEDs NeoPixel RGB direccionables\nifdef __AVR__\n   include &lt;avr/power.h&gt;  // Librer\u00eda espec\u00edfica para placas AVR (optimizaci\u00f3n de energ\u00eda)\nendif\n\n #========================================\n #CONFIGURACI\u00d3N DE CONSTANTES\n #========================================\ndefine PIN  8          // Pin digital del ESP32 donde est\u00e1 conectado el LED NeoPixel\ndefine NUMPIXELS 1     // Cantidad total de LEDs en la tira (en este caso solo 1)\n\n# ========================================\n# INICIALIZACI\u00d3N DEL OBJETO NEOPIXEL\n# ========================================\n# Par\u00e1metros: cantidad de LEDs, pin de datos, tipo de LED (GRB) + frecuencia (800KHz)\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\n# ========================================\n# CONFIGURACI\u00d3N INICIAL (se ejecuta una sola vez)\n# ========================================\nvoid setup(){\n  Serial.begin(115200);  // Inicializar comunicaci\u00f3n serial a 115200 baudios para debug\n  pixels.begin();        // Inicializar el sistema NeoPixel (configurar pin como salida)\n}\n\n# ========================================\n# BUCLE PRINCIPAL (se ejecuta infinitamente)\n# ========================================\nvoid loop(){\n  // Paso 1: Apagar el LED (poner todos los colores en 0)\n  pixels.clear();\n\n  # Paso 2: Configurar el color del LED en \u00edndice 0\n  # Color morado: Rojo=122, Verde=0, Azul=122\n  # Valores van de 0 (apagado) a 255 (m\u00e1ximo brillo)\n  pixels.setPixelColor(0, pixels.Color(122, 0, 122));\n\n  # Paso 3: Enviar los datos al LED para que muestre el color configurado\n  pixels.show();\n\n  # Paso 4: Mantener el LED encendido durante 700 milisegundos (0.7 segundos)\n  delay(700);\n\n  # El ciclo se repite: el LED se apaga brevemente y vuelve a encender, creando un efecto de parpadeo en color morado\n}\n</code></pre>"},{"location":"practica1/#3-evidencias-del-resultado-final","title":"3) Evidencias del resultado final \ud83d\udcf8","text":"<p>VIDEO MUESTRA YT</p>"},{"location":"practica2/","title":"\ud83d\udcda Pr\u00e1ctica 2 - Comunicaci\u00f3nSerial_NeoPixel","text":"<p>El programa controla un LED NeoPixel mediante comunicaci\u00f3n serial (Serial.begin(115200)), encendi\u00e9ndolo en color magenta (RGB: 122, 0, 122) \u00fanicamente cuando recibe un mensaje (if Serial.available() &gt; 0 y Serial.readStringUntil('\\n')). Ocupamos conceptos de control de LEDs RGB con pixels.setPixelColor() y pixels.show(), lectura de datos seriales y condicionales. Es ideal para aprender la interacci\u00f3n entre Arduino y dispositivos externos mediante el puerto serial, permitiendo activar el LED bajo demanda.</p>"},{"location":"practica2/#1-resumen","title":"1) Resum\u00e9n \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): Emmanuel Angeles Barreto</li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 23/09/25  </li> </ul>"},{"location":"practica2/#2-codigo","title":"2) C\u00f3digo \u2328\ufe0f","text":""},{"location":"practica2/#desde-el-primer-include-hasta-el-ultimo-define-llevan-codigo-2-control-de-led-neopixel-por-comunicacion-serial-desde-el-primer-include-hasta-el-ultimo-define-llevan-include-adafruit_neopixelh-libreria-para-controlar-leds-neopixel-rgb-direccionables-ifdef-__avr__-include-avrpowerh-libreria-especifica-para-placas-avr-optimizacion-de-energia-endif-configuracion-de-constantes-define-pin-8-pin-digital-del-esp32-donde-esta-conectado-el-led-neopixel-define-numpixels-1-cantidad-total-de-leds-en-la-tira-en-este-caso-solo-1-inicializacion-del-objeto-neopixel-parametros-cantidad-de-leds-pin-de-datos-tipo-de-led-grb-frecuencia-800khz-adafruit_neopixel-pixelsnumpixels-pin-neo_grb-neo_khz800-configuracion-inicial-se-ejecuta-una-sola-vez-void-setup-serialbegin115200-inicializar-comunicacion-serial-a-115200-baudios-para-recibir-comandos-pixelsbegin-inicializar-el-sistema-neopixel-configurar-pin-como-salida-bucle-principal-se-ejecuta-infinitamente-void-loop-paso-1-verificar-si-hay-datos-disponibles-en-el-puerto-serial-if-serialavailable-0-paso-2-leer-el-mensaje-recibido-hasta-encontrar-un-salto-de-linea-n-string-msj-serialreadstringuntiln-paso-3-mostrar-el-mensaje-recibido-en-el-serial-monitor-retroalimentacion-serialprintlnmsj-paso-4-apagar-el-led-antes-de-configurar-el-nuevo-color-pixelsclear-paso-5-configurar-el-color-del-led-en-indice-0-color-moradomagenta-rojo122-verde0-azul122-valores-van-de-0-apagado-a-255-maximo-brillo-pixelssetpixelcolor0-pixelscolor122-0-122-paso-6-enviar-los-datos-al-led-para-que-muestre-el-color-configurado-pixelsshow-paso-7-esperar-700-milisegundos-07-segundos-antes-de-la-siguiente-iteracion-este-delay-se-ejecuta-siempre-haya-o-no-mensaje-recibido-delay700-importante-el-led-solo-se-enciende-cuando-se-recibe-un-mensaje-por-el-puerto-serial-si-no-hay-mensajes-el-led-permanece-en-su-ultimo-estado","title":"<pre><code># Desde el primer include hasta el ultimo \"define\" llevan #\n# ========================================\n# C\u00d3DIGO 2: CONTROL DE LED NEOPIXEL POR COMUNICACI\u00d3N SERIAL\n# ========================================\n\n# Desde el primer include hasta el ultimo \"define\" llevan #\ninclude &lt;Adafruit_NeoPixel.h&gt;  // Librer\u00eda para controlar LEDs NeoPixel RGB direccionables\nifdef __AVR__\n   include &lt;avr/power.h&gt;  // Librer\u00eda espec\u00edfica para placas AVR (optimizaci\u00f3n de energ\u00eda)\nendif\n\n# ========================================\n# CONFIGURACI\u00d3N DE CONSTANTES\n# ========================================\ndefine PIN  8          // Pin digital del ESP32 donde est\u00e1 conectado el LED NeoPixel\ndefine NUMPIXELS 1     // Cantidad total de LEDs en la tira (en este caso solo 1)\n\n# ========================================\n# INICIALIZACI\u00d3N DEL OBJETO NEOPIXEL\n# ========================================\n# Par\u00e1metros: cantidad de LEDs, pin de datos, tipo de LED (GRB) + frecuencia (800KHz)\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\n# ========================================\n# CONFIGURACI\u00d3N INICIAL (se ejecuta una sola vez)\n# ========================================\nvoid setup(){\n  Serial.begin(115200);  // Inicializar comunicaci\u00f3n serial a 115200 baudios para recibir comandos\n  pixels.begin();        // Inicializar el sistema NeoPixel (configurar pin como salida)\n}\n\n# ========================================\n# BUCLE PRINCIPAL (se ejecuta infinitamente)\n# ========================================\nvoid loop(){\n  # Paso 1: Verificar si hay datos disponibles en el puerto serial\n  if (Serial.available() &gt; 0){\n\n    # Paso 2: Leer el mensaje recibido hasta encontrar un salto de l\u00ednea ('\\n')\n    String msj = Serial.readStringUntil('\\n');\n\n    # Paso 3: Mostrar el mensaje recibido en el Serial Monitor (retroalimentaci\u00f3n)\n    Serial.println(msj);\n\n    # Paso 4: Apagar el LED antes de configurar el nuevo color\n    pixels.clear();\n\n    # Paso 5: Configurar el color del LED en \u00edndice 0\n    # Color morado/magenta: Rojo=122, Verde=0, Azul=122\n    # Valores van de 0 (apagado) a 255 (m\u00e1ximo brillo)\n    pixels.setPixelColor(0, pixels.Color(122, 0, 122));\n\n    # Paso 6: Enviar los datos al LED para que muestre el color configurado\n    pixels.show();\n  }\n\n  # Paso 7: Esperar 700 milisegundos (0.7 segundos) antes de la siguiente iteraci\u00f3n\n  # Este delay se ejecuta siempre, haya o no mensaje recibido\n  delay(700);\n\n  # IMPORTANTE: El LED solo se enciende cuando se recibe un mensaje por el puerto serial\n  # Si no hay mensajes, el LED permanece en su \u00faltimo estado\n}\n</code></pre>","text":""},{"location":"practica2/#3-evidencias-del-resultado-final","title":"3) Evidencias del resultado final \ud83d\udcf8","text":"<p>VIDEO MUESTRA YT</p>"},{"location":"practica3/","title":"\ud83d\udcda Pr\u00e1ctica 3 - NeoPixel_ColorVariable","text":"<p>El programa controla un LED NeoPixel mediante comunicaci\u00f3n serial (Serial.begin(115200)), permitiendo cambiar din\u00e1micamente el color RGB enviando un mensaje con formato espec\u00edfico \"Red X, Green Y, Blue Z\" (usando sscanf() para extraer valores y msj.trim() para limpiar espacios). Ocupamos conceptos de control de LEDs RGB con pixels.setPixelColor() y pixels.show(), procesamiento de cadenas de texto, variables din\u00e1micas (int Red, Green, Blue) y condicionales. Es ideal para aprender la interacci\u00f3n avanzada entre Arduino y dispositivos externos mediante el puerto serial, permitiendo personalizar completamente el color del LED bajo demanda con Serial.printf() para retroalimentaci\u00f3n.</p>"},{"location":"practica3/#1-resumen","title":"1) Resum\u00e9n \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): Emmanuel Angeles Barreto</li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 23/09/25  </li> </ul>"},{"location":"practica3/#2-codigo","title":"2) C\u00f3digo \u2328\ufe0f","text":""},{"location":"practica3/#codigo-3-control-de-led-neopixel-con-color-rgb-personalizable-por-serial-desde-el-primer-include-hasta-el-ultimo-define-llevan-include-adafruit_neopixelh-libreria-para-controlar-leds-neopixel-rgb-direccionables-ifdef-__avr__-include-avrpowerh-libreria-especifica-para-placas-avr-optimizacion-de-energia-endif-configuracion-de-constantes-define-pin-8-pin-digital-del-esp32-donde-esta-conectado-el-led-neopixel-define-numpixels-1-cantidad-total-de-leds-en-la-tira-en-este-caso-solo-1-inicializacion-del-objeto-neopixel-parametros-cantidad-de-leds-pin-de-datos-tipo-de-led-grb-frecuencia-800khz-adafruit_neopixel-pixelsnumpixels-pin-neo_grb-neo_khz800-declaracion-de-variables-globales-para-almacenar-colores-rgb-int-red-variable-para-almacenar-el-valor-del-color-rojo-0-255-int-green-variable-para-almacenar-el-valor-del-color-verde-0-255-int-blue-variable-para-almacenar-el-valor-del-color-azul-0-255-configuracion-inicial-se-ejecuta-una-sola-vez-void-setup-serialbegin115200-inicializar-comunicacion-serial-a-115200-baudios-para-recibir-comandos-rgb-pixelsbegin-inicializar-el-sistema-neopixel-configurar-pin-como-salida-bucle-principal-se-ejecuta-infinitamente-void-loop-paso-1-verificar-si-hay-datos-disponibles-en-el-puerto-serial-if-serialavailable-0-paso-2-leer-el-mensaje-recibido-hasta-encontrar-un-salto-de-linea-n-string-msj-serialreadstringuntiln-paso-3-limpiar-espacios-en-blanco-al-inicio-y-final-del-mensaje-esto-asegura-que-el-formato-sea-correcto-para-el-procesamiento-msjtrim-paso-4-extraer-los-valores-numericos-r-g-b-de-la-cadena-de-texto-formato-esperado-red-255-green-100-blue-50-sscanf-busca-este-patron-y-guarda-los-numeros-en-las-variables-red-green-blue-red-green-blue-son-las-direcciones-de-memoria-donde-se-guardan-los-valores-sscanfmsjc_str-red-d-green-d-blue-d-red-green-blue-paso-5-mostrar-los-valores-extraidos-en-el-serial-monitor-retroalimentacion-serialprintf-permite-imprimir-con-formato-tipo-c-serialprintfvalores-redd-greend-bluedn-red-green-blue-paso-6-apagar-el-led-antes-de-configurar-el-nuevo-color-pixelsclear-paso-7-configurar-el-color-del-led-con-los-valores-personalizados-recibidos-ahora-el-color-es-completamente-variable-segun-lo-que-envie-el-usuario-pixelssetpixelcolor0-pixelscolorred-green-blue-paso-8-enviar-los-datos-al-led-para-que-muestre-el-color-configurado-pixelsshow-paso-9-esperar-700-milisegundos-07-segundos-antes-de-la-siguiente-iteracion-delay700-importante-el-led-se-enciende-con-el-color-rgb-que-el-usuario-especifique-ejemplo-de-mensaje-a-enviar-red-255-green-0-blue-0-para-color-rojo-puro-el-formato-debe-ser-exacto-para-que-sscanf-pueda-extraer-los-valores-correctamente","title":"<pre><code># ========================================\n# C\u00d3DIGO 3: CONTROL DE LED NEOPIXEL CON COLOR RGB PERSONALIZABLE POR SERIAL\n# ========================================\n\n# Desde el primer include hasta el ultimo \"define\" llevan #\ninclude &lt;Adafruit_NeoPixel.h&gt;  // Librer\u00eda para controlar LEDs NeoPixel RGB direccionables\nifdef __AVR__\n   include &lt;avr/power.h&gt;  // Librer\u00eda espec\u00edfica para placas AVR (optimizaci\u00f3n de energ\u00eda)\nendif\n\n# ========================================\n# CONFIGURACI\u00d3N DE CONSTANTES\n# ========================================\ndefine PIN  8          // Pin digital del ESP32 donde est\u00e1 conectado el LED NeoPixel\ndefine NUMPIXELS 1     // Cantidad total de LEDs en la tira (en este caso solo 1)\n\n# ========================================\n# INICIALIZACI\u00d3N DEL OBJETO NEOPIXEL\n# ========================================\n# Par\u00e1metros: cantidad de LEDs, pin de datos, tipo de LED (GRB) + frecuencia (800KHz)\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\n# ========================================\n# DECLARACI\u00d3N DE VARIABLES GLOBALES PARA ALMACENAR COLORES RGB\n# ========================================\nint Red;    // Variable para almacenar el valor del color Rojo (0-255)\nint Green;  // Variable para almacenar el valor del color Verde (0-255)\nint Blue;   // Variable para almacenar el valor del color Azul (0-255)\n\n# ========================================\n# CONFIGURACI\u00d3N INICIAL (se ejecuta una sola vez)\n# ========================================\nvoid setup(){\n  Serial.begin(115200);  // Inicializar comunicaci\u00f3n serial a 115200 baudios para recibir comandos RGB\n  pixels.begin();        // Inicializar el sistema NeoPixel (configurar pin como salida)\n}\n\n# ========================================\n# BUCLE PRINCIPAL (se ejecuta infinitamente)\n# ========================================\nvoid loop(){\n  # Paso 1: Verificar si hay datos disponibles en el puerto serial\n  if (Serial.available() &gt; 0){\n\n    # Paso 2: Leer el mensaje recibido hasta encontrar un salto de l\u00ednea ('\\n')\n    String msj = Serial.readStringUntil('\\n');\n\n    # Paso 3: Limpiar espacios en blanco al inicio y final del mensaje\n    # Esto asegura que el formato sea correcto para el procesamiento\n    msj.trim();\n\n    # Paso 4: Extraer los valores num\u00e9ricos R, G, B de la cadena de texto\n    # Formato esperado: \"Red 255, Green 100, Blue 50\"\n    # sscanf() busca este patr\u00f3n y guarda los n\u00fameros en las variables Red, Green, Blue\n    # &amp;Red, &amp;Green, &amp;Blue son las direcciones de memoria donde se guardan los valores\n    sscanf(msj.c_str(), \"Red %d, Green %d, Blue %d\", &amp;Red, &amp;Green, &amp;Blue);\n\n    # Paso 5: Mostrar los valores extra\u00eddos en el Serial Monitor (retroalimentaci\u00f3n)\n    # Serial.printf() permite imprimir con formato tipo C\n    Serial.printf(\"Valores: Red=%d, Green=%d, Blue=%d\\n\", Red, Green, Blue);\n\n    # Paso 6: Apagar el LED antes de configurar el nuevo color\n    pixels.clear();\n\n    # Paso 7: Configurar el color del LED con los valores personalizados recibidos\n    # Ahora el color es completamente variable seg\u00fan lo que env\u00ede el usuario\n    pixels.setPixelColor(0, pixels.Color(Red, Green, Blue));\n\n    # Paso 8: Enviar los datos al LED para que muestre el color configurado\n    pixels.show();\n  }\n\n  # Paso 9: Esperar 700 milisegundos (0.7 segundos) antes de la siguiente iteraci\u00f3n\n  delay(700);\n\n  # IMPORTANTE: El LED se enciende con el color RGB que el usuario especifique\n  # Ejemplo de mensaje a enviar: \"Red 255, Green 0, Blue 0\" para color rojo puro\n  # El formato DEBE ser exacto para que sscanf() pueda extraer los valores correctamente\n}\n</code></pre>","text":""},{"location":"practica3/#3-evidencias-del-resultado-final","title":"3) Evidencias del resultado final \ud83d\udcf8","text":"<p>VIDEO MUESTRA YT</p>"},{"location":"practica4/","title":"\ud83d\udcda Pr\u00e1ctica 4 - Pr\u00e1ctica_Comunicaci\u00f3nSerial_NeoPixel","text":"<p>El programa convierte el ESP32 en un \"asistente de colores\", que entiende comandos en \"espa\u00f1ol\", procesa la informaci\u00f3n usando funciones como indexof() y substring() para entender comandos. Es importante saber esto pues ense\u00f1a conceptos de comunicaci\u00f3n entre dispositivos (hardaware externo), como procesar datos de texto y uso de librerias.</p>"},{"location":"practica4/#1-resumen","title":"1) Resum\u00e9n \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): Emmanuel Angeles Barreto</li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 23/09/25  </li> </ul>"},{"location":"practica4/#2-codigo","title":"2) C\u00f3digo \u2328\ufe0f","text":""},{"location":"practica4/#libreria-para-controlar-leds-neopixel-de-adafruit-desde-el-primer-include-hasta-el-ultimo-define-llevan-include-adafruit_neopixelh-ifdef-_avr_-include-avrpowerh-endif-configuracion-de-constantes-del-sistema-define-delayval-1000-tiempo-de-espera-en-milisegundos-entre-comandos-define-pin-8-pin-digital-donde-esta-conectado-el-led-neopixel-define-numpixels-1-cantidad-de-leds-en-la-tira-solo-1-led-inicializacion-del-objeto-neopixel-con-configuracion-grb-y-frecuencia-800khz-adafruit_neopixel-pixelsnumpixels-pin-neo_grb-neo_khz800-string-cmd-variable-global-para-almacenar-los-comandos-recibidos-por-serial-funcion-para-procesar-colores-rgb-personalizados-void-rgbcompletostring-input-int-r-g-b-variables-para-almacenar-valores-de-rojo-verde-y-azul-0-255-buscar-la-posicion-de-las-comas-separadoras-en-el-texto-int-koma1-inputindexof-primera-coma-int-koma2-inputindexof-koma1-1-segunda-coma-extraer-y-convertir-cada-valor-rgb-desde-el-string-r-inputsubstring0-koma1toint-valor-rojo-desde-inicio-hasta-primera-coma-g-inputsubstringkoma1-1-koma2toint-valor-verde-entre-las-dos-comas-b-inputsubstringkoma2-1toint-valor-azul-despues-de-la-segunda-coma-aplicar-el-color-al-led-y-mostrarlo-pixelssetpixelcolor0-pixelscolorr-g-b-configurar-color-en-el-led-0-pixelsshow-enviar-datos-al-led-para-que-se-actualice-delaydelayval-pausa-para-estabilizar-confirmar-al-usuario-que-color-se-aplico-serialprintlnrgb-stringr-stringg-stringb-configuracion-inicial-que-se-ejecuta-una-sola-vez-void-setup-serialbegin115200-inicializar-comunicacion-serial-a-115200-baudios-pixelsbegin-inicializar-el-sistema-neopixel-mostrar-instrucciones-de-uso-al-usuario-serialprintlncomandos-berde-roho-asul-al-contrario-puedes-apagarlo-con-off-o-escoger-las-siguientes-opciones-serialprintlnrgb-personalizado-rgb-ejemplo-25510050-bucle-principal-que-se-ejecuta-infinitamente-void-loop-verificar-si-hay-datos-disponibles-en-el-puerto-serial-ifserialavailable0-cmd-serialreadstringuntiln-leer-comando-hasta-encontrar-salto-de-linea-cmdtrim-eliminar-espacios-en-blanco-al-inicio-y-final-determinar-tipo-de-comando-recibido-y-ejecutar-accion-correspondiente-si-contiene-coma-es-un-comando-rgb-personalizado-ejemplo-25512864-ifcmdindexof-1-rgbcompletocmd-llamar-funcion-para-procesar-valores-rgb-comandos-de-colores-predefinidos-else-ifcmdberde-pixelssetpixelcolor0-pixelscolor0150-0-verde-medio-intensidad-pixelsshow-delaydelayval-serialprintlncolor-verde-encendido-else-ifcmdroho-pixelssetpixelcolor0-pixelscolor1500-0-rojo-medio-intensidad-pixelsshow-delaydelayval-serialprintlncolor-roho-encendido-else-ifcmdasul-pixelssetpixelcolor0-pixelscolor00-150-azul-medio-intensidad-pixelsshow-delaydelayval-serialprintlncolor-blue-encendido-comando-para-apagar-el-led-else-if-cmdoff-pixelsclear-apagar-todos-los-leds-poner-en-000-pixelsshow-aplicar-cambios-delaydelayval-serialprintlnpicsel-apagado-manejo-de-errores-para-comandos-no-reconocidos-else-serialprintlncomando-no-reconocido","title":"<pre><code># Librer\u00eda para controlar LEDs NeoPixel de Adafruit\n# Desde el primer include hasta el ultimo \"define\" llevan #\ninclude &lt;Adafruit_NeoPixel.h&gt;\nifdef _AVR_\n include &lt;avr/power.h&gt; \nendif\n\n# Configuraci\u00f3n de constantes del sistema\ndefine DELAYVAL 1000  # Tiempo de espera en milisegundos entre comandos\ndefine PIN  8         # Pin digital donde est\u00e1 conectado el LED NeoPixel\ndefine NUMPIXELS 1    # Cantidad de LEDs en la tira (solo 1 LED)\n\n# Inicializaci\u00f3n del objeto NeoPixel con configuraci\u00f3n GRB y frecuencia 800KHz\nAdafruit_NeoPixel pixels(NUMPIXELS, PIN, NEO_GRB + NEO_KHZ800);\n\nString cmd = \"\"; # Variable global para almacenar los comandos recibidos por  serial\n\n# Funci\u00f3n para procesar colores RGB personalizados\nvoid RGBcompleto(String input) {\n  int r, g, b; # Variables para almacenar valores de Rojo, Verde y Azul (0-255)\n\n  # Buscar la posici\u00f3n de las comas separadoras en el texto\n  int koma1 = input.indexOf(',');           # Primera coma\n  int koma2 = input.indexOf(',', koma1 + 1); # Segunda coma\n\n  # Extraer y convertir cada valor RGB desde el string\n  r = input.substring(0, koma1).toInt();             # Valor rojo: desde inicio hasta primera coma\n  g = input.substring(koma1 + 1, koma2).toInt();     # Valor verde: entre las dos comas\n  b = input.substring(koma2 + 1).toInt();            # Valor azul: despu\u00e9s de la segunda coma\n\n  # Aplicar el color al LED y mostrarlo\n  pixels.setPixelColor(0, pixels.Color(r, g, b));  # Configurar color en el LED #0\n  pixels.show();                                   # Enviar datos al LED para que se actualice\n  delay(DELAYVAL);                                 # Pausa para estabilizar\n\n  # Confirmar al usuario qu\u00e9 color se aplic\u00f3\n  Serial.println(\"RGB: \" + String(r) + \",\" + String(g) + \",\" + String(b));\n}\n\n# Configuraci\u00f3n inicial que se ejecuta una sola vez\nvoid setup() {\n  Serial.begin(115200);  # Inicializar comunicaci\u00f3n serial a 115200 baudios\n  pixels.begin();        # Inicializar el sistema NeoPixel\n\n  # Mostrar instrucciones de uso al usuario\n  Serial.println(\"Comandos: berde, roho, asul, al contrario puedes apagarlo con OFF, o escoger las siguientes opciones\");\n  Serial.println(\"RGB personalizado: R,G,B (ejemplo: 255,100,50)\");\n}\n\n# Bucle principal que se ejecuta infinitamente\nvoid loop() {\n  # Verificar si hay datos disponibles en el puerto serial\n  if(Serial.available()&gt;0){\n    cmd = Serial.readStringUntil('\\n');  # Leer comando hasta encontrar salto de l\u00ednea\n    cmd.trim();                          # Eliminar espacios en blanco al inicio y final\n\n    # Determinar tipo de comando recibido y ejecutar acci\u00f3n correspondiente\n\n    # Si contiene coma, es un comando RGB personalizado (ejemplo: 255,128,64)\n    if(cmd.indexOf(',') != -1) {\n      RGBcompleto(cmd);  # Llamar funci\u00f3n para procesar valores RGB\n    }\n    # Comandos de colores predefinidos\n    else if(cmd==\"berde\") {\n      pixels.setPixelColor(0, pixels.Color(0,150, 0));  # Verde medio intensidad\n      pixels.show(); \n      delay(DELAYVAL);\n      Serial.println(\"color verde encendido\");\n    }\n    else if(cmd==\"roho\") {\n      pixels.setPixelColor(0, pixels.Color(150,0, 0));  # Rojo medio intensidad\n      pixels.show();\n      delay(DELAYVAL); \n      Serial.println(\"color roho encendido\");\n    }\n    else if(cmd==\"asul\") {\n      pixels.setPixelColor(0, pixels.Color(0,0, 150));  # Azul medio intensidad\n      pixels.show(); \n      delay(DELAYVAL);\n      Serial.println(\"color blue encendido\");\n    }\n    # Comando para apagar el LED\n    else if (cmd==\"OFF\") { \n      pixels.clear();   # Apagar todos los LEDs (poner en 0,0,0)\n      pixels.show();    # Aplicar cambios\n      delay(DELAYVAL);\n      Serial.println(\"picsel apagado\");\n    }\n    # Manejo de errores para comandos no reconocidos\n    else {\n      Serial.println(\"Comando no reconocido\");\n    }\n  }\n}\n</code></pre>","text":""},{"location":"practica4/#3-evidencias-del-resultado-final","title":"3) Evidencias del resultado final \ud83d\udcf8","text":"<p>VIDEO MUESTRA YT</p>"},{"location":"practica5/","title":"\ud83d\udcdaPRACTICA 5 - Comunicaci\u00f3n_BLE_B\u00e1sica","text":""},{"location":"practica5/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): ANGELES_BARRETO_EMMANUEL, CEREZO_PONCE_JESUS_ALFREDO </li> <li>Curso / Asignatura: ELEMENTOS_PROGRAMABLES_II </li> <li>Descripci\u00f3n breve: El programa configura un ESP32 como dispositivo Bluetooth Low Energy (BLE) que anuncia un servicio y una caracter\u00edstica; permite comunicaci\u00f3n b\u00e1sica con clientes BLE (smartphone, PC) para lectura/escritura de una cadena de texto.</li> </ul>"},{"location":"practica5/#2-objetivos","title":"2) Objetivos","text":"<ul> <li> <p>General: Implementar la comunicaci\u00f3n inal\u00e1mbrica mediante Bluetooth Low Energy (BLE) en el ESP32, comprendiendo el proceso de creaci\u00f3n de un servidor BLE y su interacci\u00f3n con dispositivos clientes. </p> </li> <li> <p>Espec\u00edficos: </p> </li> <li>Configurar el ESP32 como servidor BLE con un servicio personalizado. </li> <li>Crear una caracter\u00edstica BLE con permisos de lectura y escritura. </li> <li>Analizar el funcionamiento del modo advertising y su detecci\u00f3n por otros dispositivos. </li> <li>Comprobar la comunicaci\u00f3n entre el ESP32 y una aplicaci\u00f3n m\u00f3vil BLE. </li> </ul>"},{"location":"practica5/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li> <p>Incluye: El desarrollo de un servidor BLE funcional utilizando el ESP32, capaz de anunciar un servicio y permitir la lectura y escritura de datos desde una aplicaci\u00f3n cliente BLE (como nRF Connect o LightBlue). </p> </li> <li> <p>No incluye: La implementaci\u00f3n de m\u00faltiples servicios simult\u00e1neos, encriptaci\u00f3n de datos BLE, ni la integraci\u00f3n con WiFi, Internet o plataformas IoT externas. </p> </li> </ul>"},{"location":"practica5/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Arduino IDE versi\u00f3n 2.0 o superior. - Extensi\u00f3n de tarjetas ESP32 instalada desde el Gestor de Tarjetas. - Librer\u00edas necesarias: BLEDevice.h, BLEUtils.h y BLEServer.h. - Aplicaci\u00f3n m\u00f3vil para pruebas BLE (nRF Connect, LightBlue, o similar). </p> <p>Hardware - Microcontrolador ESP32 DevKit v1. - Cable USB para conexi\u00f3n y carga del programa. - Computadora con sistema operativo Windows, Linux o macOS. </p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en C++ y entorno Arduino. - Conceptos de comunicaci\u00f3n inal\u00e1mbrica (Bluetooth/BLE). - Uso de herramientas de monitoreo serial y escaneo BLE. </p>"},{"location":"practica5/#5-instalacion-codigo","title":"5) Instalaci\u00f3n / C\u00f3digo \u2328\ufe0f","text":"<pre><code># ========================================\n# LIBRER\u00cdAS NECESARIAS\n# ========================================\ninclude &lt;BLEDevice.h&gt;\ninclude &lt;BLEUtils.h&gt;\ninclude &lt;BLEServer.h&gt;\n\n# ========================================\n# CONFIGURACI\u00d3N PRINCIPAL (versi\u00f3n ajustada)\n# ========================================\nstatic const char* DEVICE_NAME = \"AK_BLE_Node\";  # Nombre visible al escanear\ndefine SERVICE_UUID_NEW        \"87654321-4321-4321-4321-0987654321ab\"\ndefine CHARACTERISTIC_UUID_NEW \"dcba4321-8765-09ab-cdef-0123456789ab\"\n\n# ========================================\n# CONFIGURACI\u00d3N INICIAL (setup)\n# ========================================\nvoid setup() {\n  Serial.begin(115200);\n  delay(120);  # peque\u00f1o retardo para estabilizar el puerto serie\n\n  # Inicializa BLE con el nombre definido arriba\n  BLEDevice::init(DEVICE_NAME);\n\n  # Crea servidor BLE y agrega un servicio con UUID personalizado\n  BLEServer* pServer = BLEDevice::createServer();\n  BLEService* pService = pServer-&gt;createService(SERVICE_UUID_NEW);\n\n  # Crea una caracter\u00edstica con permisos de lectura y escritura\n  BLECharacteristic* pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUID_NEW,\n      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE\n  );\n\n  # Valor inicial de la caracter\u00edstica (puedes cambiarlo desde un cliente BLE)\n  pCharacteristic-&gt;setValue(\"Hola mundo BLE\");\n\n  # Arranca el servicio para hacerlo disponible\n  pService-&gt;start();\n\n  # Configura el advertising para que el dispositivo sea detectable\n  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;addServiceUUID(SERVICE_UUID_NEW);   # Anuncia el UUID del servicio\n  pAdvertising-&gt;setScanResponse(true);              # Incluir respuesta de escaneo\n  pAdvertising-&gt;setMinPreferred(0x06);              # Par\u00e1metros recomendados por el core\n  pAdvertising-&gt;setMinPreferred(0x12);\n\n  # Inicia la publicidad BLE (advertising)\n  BLEDevice::startAdvertising();\n  Serial.println(\"BLE Advertising iniciado (AK_BLE_Node)\");\n}\n\n# ========================================\n# BUCLE PRINCIPAL (loop)\n# ========================================\nvoid loop() {\n  # El advertising funciona en background; no es necesario hacer nada aqu\u00ed\n  delay(1000);\n}\n</code></pre>"},{"location":"practica5/#5-conclusion","title":"5) Conclusi\u00f3n \ud83e\udde0","text":"<p>En esta pr\u00e1ctica se logr\u00f3 implementar un servidor Bluetooth Low Energy (BLE) en el ESP32, comprendiendo el proceso de inicializaci\u00f3n, creaci\u00f3n de servicios y caracter\u00edsticas, as\u00ed como la transmisi\u00f3n de informaci\u00f3n mediante el modo advertising. Se verific\u00f3 la conexi\u00f3n con dispositivos externos y la capacidad del microcontrolador para actuar como un servidor BLE estable y de bajo consumo, lo cual es esencial en aplicaciones de IoT, monitoreo inal\u00e1mbrico y sistemas port\u00e1tiles inteligentes. Esta pr\u00e1ctica refuerza los fundamentos de la comunicaci\u00f3n inal\u00e1mbrica moderna y sienta las bases para proyectos m\u00e1s complejos que integren BLE con sensores y plataformas m\u00f3viles.  </p>"},{"location":"practica6/","title":"\ud83d\udcdaPRACTICA 6 - Comunicaci\u00f3n wifi","text":""},{"location":"practica6/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): ANGELES_BARRETO_EMMANUEL, CEREZO_PONCE_JESUS_ALFREDO </li> <li>Curso / Asignatura: ELEMENTOS_PROGRAMABLES_II </li> <li>Descripci\u00f3n breve: El programa configura un ESP32 como dispositivo Bluetooth Low Energy (BLE) que anuncia un servicio y una caracter\u00edstica; permite comunicaci\u00f3n b\u00e1sica con clientes BLE (smartphone, PC) para lectura/escritura de una cadena de texto.</li> </ul>"},{"location":"practica6/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: Implementar la comunicaci\u00f3n BLE en el ESP32 para transmitir y recibir datos b\u00e1sicos y comprender la estructura de servicios y caracter\u00edsticas BLE. </li> <li>Espec\u00edficos: </li> <li>Inicializar el m\u00f3dulo BLE con un nombre identificable. </li> <li>Crear un servicio y una caracter\u00edstica con UUIDs personalizados. </li> <li>Anunciar (advertise) el servicio para que clientes BLE lo detecten. </li> <li>Probar la lectura/escritura de la caracter\u00edstica desde un cliente BLE.</li> </ul>"},{"location":"practica6/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: Configuraci\u00f3n del ESP32 como servidor BLE, creaci\u00f3n de servicio y caracter\u00edstica, y advertising para pruebas con apps BLE. </li> <li>No incluye: Conexiones m\u00faltiples avanzadas, seguridad/pareo complejo ni el desarrollo de una app m\u00f3vil dedicada.</li> </ul>"},{"location":"practica6/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Arduino IDE 2.0+ con soporte ESP32 instalado. - Librer\u00edas: BLEDevice.h, BLEUtils.h, BLEServer.h (incluidas en el core ESP32). </p> <p>Hardware - ESP32 DevKit v1. - Cable USB para programaci\u00f3n. - Dispositivo cliente con BLE (smartphone/tablet). </p> <p>Conocimientos previos - Arduino/C++ b\u00e1sico. - Conocimientos b\u00e1sicos de BLE y debugging por Serial.</p>"},{"location":"practica6/#5-instalacion-codigo","title":"5) Instalaci\u00f3n / C\u00f3digo \u2328\ufe0f","text":"<pre><code>#include &lt;BLEDevice.h&gt;\n#include &lt;BLEUtils.h&gt;\n#include &lt;BLEServer.h&gt;\n\n// ====== Configuraci\u00f3n ======\nstatic const char* DEVICE_NAME = \"AKDevice\";  // Nombre que ver\u00e1s en el escaneo\n#define SERVICE_UUID        \"12345678-1234-1234-1234-1234567890ab\"\n#define CHARACTERISTIC_UUID \"abcd1234-5678-90ab-cdef-1234567890ab\"\n\nvoid setup() {\n  Serial.begin(115200);\n  delay(100);\n\n  // 1) Inicializa BLE con nombre\n  BLEDevice::init(DEVICE_NAME);\n\n  // 2) Crea servidor y servicio\n  BLEServer*      pServer  = BLEDevice::createServer();\n  BLEService*     pService = pServer-&gt;createService(SERVICE_UUID);\n\n  // 3) Caracter\u00edstica de ejemplo (Lectura/Escritura)\n  BLECharacteristic* pCharacteristic = pService-&gt;createCharacteristic(\n      CHARACTERISTIC_UUID,\n      BLECharacteristic::PROPERTY_READ   |\n      BLECharacteristic::PROPERTY_WRITE\n  );\n  pCharacteristic-&gt;setValue(\"Hola BLE\");\n\n  // 4) Inicia el servicio\n  pService-&gt;start();\n\n  // 5) Configura el advertising\n  BLEAdvertising* pAdvertising = BLEDevice::getAdvertising();\n  pAdvertising-&gt;addServiceUUID(SERVICE_UUID);   // Anuncia el UUID del servicio\n  pAdvertising-&gt;setScanResponse(true);          // Info extra en la respuesta de escaneo\n  pAdvertising-&gt;setMinPreferred(0x06);          // Par\u00e1metros recomendados\n  pAdvertising-&gt;setMinPreferred(0x12);\n\n  // 6) Inicia advertising\n  BLEDevice::startAdvertising();\n  Serial.println(\"BLE Advertising started\");\n}\n\nvoid loop() {\n  // Nada en el loop; el anuncio corre en segundo plano\n  delay(1000);\n}\n</code></pre> <p>En esta pr\u00e1ctica se logr\u00f3 implementar la comunicaci\u00f3n Bluetooth Low Energy (BLE) utilizando el ESP32 como servidor BLE. Se comprendi\u00f3 la estructura del protocolo BLE, la diferencia entre servicios y caracter\u00edsticas, y c\u00f3mo establecer comunicaci\u00f3n con un cliente BLE (por ejemplo, desde una app en un smartphone). El resultado demuestra la capacidad del ESP32 para operar como un dispositivo IoT eficiente y de bajo consumo, capaz de transmitir informaci\u00f3n sin necesidad de WiFi, ideal para aplicaciones port\u00e1tiles, sensores inteligentes y proyectos de automatizaci\u00f3n inal\u00e1mbrica.  </p>"},{"location":"practica7/","title":"\ud83d\udcdaPRACTICA 7 - Servidor_Web_LED_Control","text":""},{"location":"practica7/#1-resumen","title":"1) Resumen","text":"<ul> <li>Equipo / Autor(es): ANGELES BARRETO EMMANUEL, CEREZO PONCE JESUS ALFREDO </li> <li>Curso / Asignatura: ELEMENTOS PROGRAMABLES II </li> <li>Descripci\u00f3n breve: El programa convierte el ESP32 en un servidor web local, permitiendo encender y apagar LEDs desde una p\u00e1gina HTML alojada en el propio microcontrolador.</li> </ul>"},{"location":"practica7/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: _ Implementar un servidor web en el ESP32 que permita el control remoto de LEDs mediante una interfaz HTML, comprendiendo el funcionamiento del protocolo HTTP y la comunicaci\u00f3n entre cliente-servidor embebido._</li> <li>Espec\u00edficos:</li> <li>Dise\u00f1ar una p\u00e1gina web b\u00e1sica alojada en el ESP32 con botones para encender y apagar LEDs. </li> <li>Programar las rutas /on y /off para controlar las salidas digitales del microcontrolador. </li> <li>Comprender el uso de las librer\u00edas WiFi.h y WebServer.h para crear un servidor local funcional. </li> <li>Evaluar la respuesta del sistema en tiempo real al interactuar desde un navegador web.</li> </ul>"},{"location":"practica7/#3-alcance-y-exclusiones","title":"3) Alcance y Exclusiones","text":"<ul> <li>Incluye: El desarrollo de un servidor web funcional en el ESP32 capaz de encender y apagar m\u00faltiples LEDs a trav\u00e9s de una p\u00e1gina HTML alojada en el propio microcontrolador, mostrando en tiempo real el estado de cada salida digital.</li> <li>No incluye: El control mediante dispositivos externos (como smartphones v\u00eda Bluetooth o MQTT), el almacenamiento de datos en bases externas, ni la integraci\u00f3n con servicios en la nube.</li> </ul>"},{"location":"practica7/#4-requisitos","title":"4) Requisitos","text":"<p>Software - Sistema Operativo compatible: Windows, Linux o macOS. - Arduino IDE versi\u00f3n 2.0 o superior. - Extensi\u00f3n de tarjetas ESP32 instalada desde el Gestor de tarjetas. - Librer\u00edas necesarias: WiFi.h y WebServer.h. </p> <p>Hardware - Microcontrolador ESP32 DevKit v1. - 3 LEDs individuales y 3 resistencias de 220\u03a9. - Cables Dupont y protoboard. - Fuente de poder o conexi\u00f3n USB para el ESP32. </p> <p>Conocimientos previos - Programaci\u00f3n b\u00e1sica en Arduino/C++. - Conceptos de electr\u00f3nica digital (entrada/salida digital, resistencias, LEDs). - Conocimiento b\u00e1sico del protocolo HTTP y estructura HTML. - Uso de Git/GitHub para documentaci\u00f3n y control de versiones. </p>"},{"location":"practica7/#5-instalacion","title":"5) Instalaci\u00f3n","text":"<pre><code># ========================================\n# LIBRER\u00cdAS NECESARIAS\n# ========================================\ninclude &lt;WiFi.h&gt;\ninclude &lt;WebServer.h&gt;\n\n# ========================================\n# CONFIGURACI\u00d3N DE RED Y PINES\n# ========================================\nconst char* ssid = \"iPhone\";\nconst char* password = \"karennajera\";\n\nWebServer server(80);\n\nconst int ledPin = 20;   # LED principal\nconst int ledPin1 = 19;  # LED secundario\nconst int ledPin2 = 21;  # LED terciario\n\nString ledState = \"OFF\";\nString ledState1 = \"OFF\";\nString ledState2 = \"OFF\";\n\n# ========================================\n# FUNCI\u00d3N BASE (P\u00e1gina principal)\n# ========================================\nvoid handleRoot() {\n  String html = \"&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset='UTF-8'&gt;&lt;title&gt;ESP32 LED Control&lt;/title&gt;&lt;/head&gt;&lt;body&gt;\";\n  html += \"&lt;h1&gt;ESP32 LED Control&lt;/h1&gt;\";\n\n  html += \"&lt;p&gt;LED 1 is \" + ledState + \"&lt;/p&gt;\";\n  if (ledState == \"OFF\")\n    html += \"&lt;a href=\\\"/on\\\"&gt;&lt;button&gt;Turn On LED 1&lt;/button&gt;&lt;/a&gt;\";\n  else\n    html += \"&lt;a href=\\\"/off\\\"&gt;&lt;button&gt;Turn Off LED 1&lt;/button&gt;&lt;/a&gt;\";\n\n  html += \"&lt;p&gt;LED 2 is \" + ledState1 + \"&lt;/p&gt;\";\n  if (ledState1 == \"OFF\")\n    html += \"&lt;a href=\\\"/on1\\\"&gt;&lt;button&gt;Turn On LED 2&lt;/button&gt;&lt;/a&gt;\";\n  else\n    html += \"&lt;a href=\\\"/off1\\\"&gt;&lt;button&gt;Turn Off LED 2&lt;/button&gt;&lt;/a&gt;\";\n\n  html += \"&lt;p&gt;LED 3 is \" + ledState2 + \"&lt;/p&gt;\";\n  if (ledState2 == \"OFF\")\n    html += \"&lt;a href=\\\"/on2\\\"&gt;&lt;button&gt;Turn On LED 3&lt;/button&gt;&lt;/a&gt;\";\n  else\n    html += \"&lt;a href=\\\"/off2\\\"&gt;&lt;button&gt;Turn Off LED 3&lt;/button&gt;&lt;/a&gt;\";\n\n  html += \"&lt;/body&gt;&lt;/html&gt;\";\n\n  server.send(200, \"text/html\", html);\n}\n\n# ========================================\n# FUNCIONES DE CONTROL DE LEDS\n# ========================================\nvoid handleOn() {\n  digitalWrite(ledPin, HIGH);\n  ledState = \"ON\";\n  handleRoot();\n}\n\nvoid handleOff() {\n  digitalWrite(ledPin, LOW);\n  ledState = \"OFF\";\n  handleRoot();\n}\n\nvoid handleOn1() {\n  digitalWrite(ledPin1, HIGH);\n  ledState1 = \"ON\";\n  handleRoot();\n}\n\nvoid handleOff1() {\n  digitalWrite(ledPin1, LOW);\n  ledState1 = \"OFF\";\n  handleRoot();\n}\n\nvoid handleOn2() {\n  digitalWrite(ledPin2, HIGH);\n  ledState2 = \"ON\";\n  handleRoot();\n}\n\nvoid handleOff2() {\n  digitalWrite(ledPin2, LOW);\n  ledState2 = \"OFF\";\n  handleRoot();\n}\n\n# ========================================\n# CONFIGURACI\u00d3N INICIAL (setup)\n# ========================================\nvoid setup() {\n  Serial.begin(115200);\n\n  pinMode(ledPin, OUTPUT);\n  digitalWrite(ledPin, LOW);\n  pinMode(ledPin1, OUTPUT);\n  digitalWrite(ledPin1, LOW);\n  pinMode(ledPin2, OUTPUT);\n  digitalWrite(ledPin2, LOW);\n\n  WiFi.begin(ssid, password);\n  while (WiFi.status() != WL_CONNECTED) {\n    delay(500);\n    Serial.print(\".\");\n  }\n  Serial.println(\"\\nWiFi connected\");\n  Serial.println(WiFi.localIP());\n\n  server.on(\"/\", handleRoot);\n  server.on(\"/on\", handleOn);\n  server.on(\"/off\", handleOff);\n  server.on(\"/on1\", handleOn1);\n  server.on(\"/off1\", handleOff1);\n  server.on(\"/on2\", handleOn2);\n  server.on(\"/off2\", handleOff2);\n\n  server.begin();\n  Serial.println(\"Server started\");\n}\n\n# ========================================\n# BUCLE PRINCIPAL (loop)\n# ========================================\nvoid loop() {\n  server.handleClient();\n}\n</code></pre> <p>En esta pr\u00e1ctica se logr\u00f3 implementar un servidor web embebido en el ESP32, permitiendo el control remoto de tres LEDs desde una p\u00e1gina HTML. Se comprendi\u00f3 el uso de las librer\u00edas WiFi.h y WebServer.h, as\u00ed como la creaci\u00f3n de rutas espec\u00edficas para ejecutar funciones dentro del microcontrolador. Este proyecto demuestra c\u00f3mo el ESP32 puede actuar como un microservidor aut\u00f3nomo, aplicando conceptos de comunicaci\u00f3n cliente-servidor, HTML din\u00e1mico y control digital en tiempo real, siendo una base s\u00f3lida para futuros desarrollos en dom\u00f3tica e IoT.  </p>"},{"location":"practica7/#evidencias-del-resultado-final","title":"Evidencias del resultado final \ud83d\udcf8","text":""},{"location":"practica9/","title":"\ud83d\udcda Pr\u00e1ctica 9 - Pr\u00e1ctica_ESP-NOW_MultiNodo_3Botones_3LEDs","text":"<p>El programa implementa una red ESP-NOW con un nodo central que lee 3 botones y env\u00eda un struct a tres ESP32 identificados por su MAC. Tambi\u00e9n se registra un callback para recibir datos; seg\u00fan el origen, se enciende/apaga el LED correspondiente. Refuerza conceptos de comunicaci\u00f3n inal\u00e1mbrica sin IP, estructuras de datos, definici\u00f3n de peers y manejo de GPIO.</p>"},{"location":"practica9/#1-resumen","title":"1) Resum\u00e9n \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): Jes\u00fas Cerezo  </li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 21/10/25  </li> </ul>"},{"location":"practica9/#2-codigo","title":"2) C\u00f3digo \u2328\ufe0f","text":"<pre><code># Librer\u00edas requeridas\ninclude &lt;esp_now.h&gt;\ninclude &lt;WiFi.h&gt;\n\n# Direcciones MAC de los 3 pares\nuint8_t broadcastAddress[]  = {0x7C, 0x2C, 0x67, 0x55, 0xD6, 0x88};  # Peer A\nuint8_t broadcastAddress2[] = {0x7C, 0x2C, 0x67, 0x55, 0xD8, 0xDC};  # Peer B\nuint8_t broadcastAddress3[] = {0x7C, 0x2C, 0x67, 0x55, 0xD4, 0xE0};  # Peer C\n\n# Pines (ajusta seg\u00fan tu placa)\nint led1 = 10;  # LED A\nint led2 = 11;  # LED B\nint led3 = 12;  # LED C\nint boton1 = 2;\nint boton2 = 3;\nint boton3 = 4;\n\n# Estructura de datos (ESP-NOW ~250 bytes m\u00e1x)\ntypedef struct struct_msj {\n  char  a[32];\n  int   b;\n  float c;\n  bool  d;\n} struct_msj;\n\n# Instancias para env\u00edo/recepci\u00f3n\nstruct_msj datosEnviados;\nstruct_msj datosRecibidos;\nstruct_msj datosEnviados2;\nstruct_msj datosRecibidos2;\nstruct_msj datosEnviados3;\nstruct_msj datosRecibidos3;\n\n# Informaci\u00f3n de peers\nesp_now_peer_info_t peerInfo;\nesp_now_peer_info_t peerInfo2;\nesp_now_peer_info_t peerInfo3;\n\n# Callback de recepci\u00f3n: decide LED seg\u00fan MAC de origen\nvoid OnDataRecv(const esp_now_recv_info_t *info, const uint8_t *tempData, int tam) {\n  memcpy(&amp;datosRecibidos, tempData, sizeof(datosRecibidos));\n\n  # (Opcional) imprimir MAC origen\n  char macStr[18];\n  snprintf(macStr, sizeof(macStr),\n           \"%02X:%02X:%02X:%02X:%02X:%02X\",\n           info-&gt;src_addr[0], info-&gt;src_addr[1], info-&gt;src_addr[2],\n           info-&gt;src_addr[3], info-&gt;src_addr[4], info-&gt;src_addr[5]);\n  Serial.printf(\"Datos recibidos de: %s\\n\", macStr);\n\n  # Mapeo por \u00faltimo byte de la MAC\n  if(info-&gt;src_addr[5] == 0x88) {              # Peer A\n    if (datosRecibidos.b == 1) digitalWrite(led1, HIGH); else digitalWrite(led1, LOW);\n  }\n  if(info-&gt;src_addr[5] == 0xE0) {              # Peer C\n    if (datosRecibidos.b == 1) digitalWrite(led2, HIGH); else digitalWrite(led2, LOW);\n  }\n  if(info-&gt;src_addr[5] == 0xDC) {              # Peer B\n    if (datosRecibidos.b == 1) digitalWrite(led3, HIGH); else digitalWrite(led3, LOW);\n  }\n\n  Serial.printf(\"Int: %d\\n\", datosRecibidos.b);\n}\n\n# Configuraci\u00f3n\nvoid setup() {\n  Serial.begin(115200);\n  WiFi.mode(WIFI_STA);   # Requerido por ESP-NOW\n\n  pinMode(boton1, INPUT);\n  pinMode(boton2, INPUT);\n  pinMode(boton3, INPUT);\n  pinMode(led1, OUTPUT);\n  pinMode(led2, OUTPUT);\n  pinMode(led3, OUTPUT);\n\n  if (esp_now_init() != ESP_OK) {\n    Serial.println(\"Error inicializando ESP-NOW\");\n    return;\n  }\n\n  # Peer 1\n  memset(&amp;peerInfo, 0, sizeof(peerInfo));\n  memcpy(peerInfo.peer_addr, broadcastAddress, 6);\n  peerInfo.channel = 0;\n  peerInfo.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo) != ESP_OK) { Serial.println(\"No se pudo agregar el peer\"); return; }\n\n  # Peer 2\n  memset(&amp;peerInfo2, 0, sizeof(peerInfo2));\n  memcpy(peerInfo2.peer_addr, broadcastAddress2, 6);\n  peerInfo2.channel = 0;\n  peerInfo2.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo2) != ESP_OK) { Serial.println(\"No se pudo agregar el peer\"); return; }\n\n  # Peer 3\n  memset(&amp;peerInfo3, 0, sizeof(peerInfo3));\n  memcpy(peerInfo3.peer_addr, broadcastAddress3, 6);\n  peerInfo3.channel = 0;\n  peerInfo3.encrypt = false;\n  if (esp_now_add_peer(&amp;peerInfo3) != ESP_OK) { Serial.println(\"No se pudo agregar el peer\"); return; }\n\n  Serial.println(\"ESP-NOW listo para enviar\");\n  esp_now_register_recv_cb(OnDataRecv);\n}\n\n# Bucle principal: lee botones y env\u00eda a cada peer\nvoid loop() {\n  # Log de botones\n  Serial.print(\"Bot\u00f3n 1: \"); Serial.print(digitalRead(boton1));\n  Serial.print(\" | Bot\u00f3n 2: \"); Serial.print(digitalRead(boton2));\n  Serial.print(\" | Bot\u00f3n 3: \"); Serial.println(digitalRead(boton3));\n\n  # Payload com\u00fan\n  strcpy(datosEnviados.a, \"Hola Mundo\");\n  datosEnviados.c = 3.14;\n  datosEnviados.d = true;\n\n  # Bot\u00f3n 1 -&gt; Peer A\n  datosEnviados.b = (digitalRead(boton1) == HIGH) ? 1 : 0;\n  esp_err_t result1 = esp_now_send(broadcastAddress,  (uint8_t*)&amp;datosEnviados, sizeof(datosEnviados));\n\n  # Bot\u00f3n 2 -&gt; Peer B\n  datosEnviados.b = (digitalRead(boton2) == HIGH) ? 1 : 0;\n  esp_err_t result2 = esp_now_send(broadcastAddress2, (uint8_t*)&amp;datosEnviados, sizeof(datosEnviados));\n\n  # Bot\u00f3n 3 -&gt; Peer C\n  datosEnviados.b = (digitalRead(boton3) == HIGH) ? 1 : 0;\n  esp_err_t result3 = esp_now_send(broadcastAddress3, (uint8_t*)&amp;datosEnviados, sizeof(datosEnviados));\n\n  delay(2000);\n}\n</code></pre>"},{"location":"proyectofinal/","title":"\ud83d\udcda PROYECTO FINAL - ELEMENTOS PROGRAMABLES II","text":""},{"location":"proyectofinal/#el-programa-implementa-una-plataforma-stewart-controlada-por-gestos-de-la-mano-mediante-vision-por-computadora-utiliza-mediapipe-para-detectar-los-landmarks-de-la-mano-muneca-dedo-medio-y-pulgar-y-calcula-dos-parametros-principales-el-pitch-inclinacion-arribaabajo-basado-en-la-profundidad-z-entre-muneca-y-dedo-medio-y-el-roll-inclinacion-izquierdaderecha-determinado-por-la-posicion-vertical-del-pulgar-estos-valores-se-procesan-con-un-filtro-exponencial-para-eliminar-tembladera-y-se-envian-via-bluetooth-classic-a-un-esp32-que-controla-3-servomotores-mg90s-en-configuracion-triangular-pines-4-5-y-15-el-esp32-recibe-comandos-en-formato-a1xa2ya3z-y-genera-senales-pwm-a-50hz-con-resolucion-de-12-bits-para-posicionar-cada-servo-refuerza-conceptos-de-procesamiento-de-imagen-en-tiempo-real-comunicacion-serial-inalambrica-control-de-actuadores-y-cinematica-inversa-basica-para-plataformas-de-movimiento","title":"&gt; El programa implementa una plataforma Stewart controlada por gestos de la mano mediante visi\u00f3n por computadora. Utiliza MediaPipe para detectar los landmarks de la mano (mu\u00f1eca, dedo medio y pulgar) y calcula dos par\u00e1metros principales: el pitch (inclinaci\u00f3n arriba/abajo) basado en la profundidad Z entre mu\u00f1eca y dedo medio, y el roll (inclinaci\u00f3n izquierda/derecha) determinado por la posici\u00f3n vertical del pulgar. Estos valores se procesan con un filtro exponencial para eliminar tembladera y se env\u00edan v\u00eda Bluetooth Classic a un ESP32, que controla 3 servomotores MG90S en configuraci\u00f3n triangular (pines 4, 5 y 15). El ESP32 recibe comandos en formato A1:x,A2:y,A3:z y genera se\u00f1ales PWM a 50Hz con resoluci\u00f3n de 12 bits para posicionar cada servo. Refuerza conceptos de procesamiento de imagen en tiempo real, comunicaci\u00f3n serial inal\u00e1mbrica, control de actuadores y cinem\u00e1tica inversa b\u00e1sica para plataformas de movimiento.","text":""},{"location":"proyectofinal/#1-resumen","title":"1) Resum\u00e9n  \ud83d\udccc","text":"<ul> <li>Equipo / Autor(es): Emmanuel Angeles Barreto  </li> <li>Curso / Asignatura: Elementos Programables II  </li> <li>Fecha: 07/12/25  </li> </ul>"},{"location":"proyectofinal/#2-objetivos","title":"2) Objetivos","text":"<ul> <li>General: _ Desarrollar un sistema de control para una plataforma Stewart de 3 grados de libertad mediante el reconocimiento de gestos de la mano utilizando visi\u00f3n por computadora y comunicaci\u00f3n inal\u00e1mbrica Bluetooth._</li> <li>Espec\u00edficos:</li> <li>OP1\u2026 Implementar la detecci\u00f3n de la mano en tiempo real utilizando la librer\u00eda MediaPipe para obtener los landmarks de mu\u00f1eca, dedo medio y pulgar</li> <li>OP2\u2026 Calcular los par\u00e1metros de inclinaci\u00f3n (pitch y roll) a partir de las posiciones relativas de los puntos de la mano y aplicar filtros para suavizar el movimiento.</li> <li>OP3\u2026 Establecer comunicaci\u00f3n Bluetooth entre Python y el ESP32 para transmitir los \u00e1ngulos calculados de forma inal\u00e1mbrica.</li> <li>OP4\u2026 Controlar 3 servomotores MG90S mediante se\u00f1ales PWM generadas por el ESP32 para inclinar la plataforma seg\u00fan los gestos detectados.</li> </ul>"},{"location":"proyectofinal/#2-instalacion","title":"2) Instalaci\u00f3n","text":"<ul> <li>Seguir el siguiente link, para poder realizar el c\u00f3digo: https://iberopuebla.sharepoint.com/:p:/s/Section_11192A-O25/Eagdi_tzhWZMgKc8luT4Fi0BwHxjPm1VrXFUaZsVAG4fsw?e=HB032a</li> </ul>"},{"location":"proyectofinal/#2-requisitos","title":"2) Requisitos","text":"<p>HARDWARE - ESP32-D - SERVOMOTORES MG90S - PROTOBOARD - CABLES DUPONT (macho-macho, macho-hembra) - FUENTE DE ALIMENTACI\u00d3N (6v para los servos) - C\u00c1MARA WEB O CAMARA INTEGRADA DE LAPTOP - ESTRUCTURA DE PLATAFORMA STEWART IMPRESA EN 3D</p> <p>SOFTWARE) - ARDUINO IDE (para programar ESP32-D) - VISUAL STUDIO CODE (python) - LIBRERIAS DE PYTHON</p> <p>CONOCIMIENTOS PREVIOS - PROGRAMACI\u00d3N EN Python - PROGRAMACI\u00d3N EN C++(arduino) - COMUNICACI\u00d3N SERIAL Y BLUETOOTH - CONTROL DE SERVOMOTORES CON PWM - _ELECTR\u00d3NICA B\u00c1SICA _</p>"},{"location":"proyectofinal/#2-piezas-a-utilizar","title":"2) PIEZAS A UTILIZAR \u2328","text":"<ul> <li>La pieza mostrada corresponde a la base central del proyecto.Su geometr\u00eda se compone de un contenedor con forma poligonal, con paredes altas que brindan rigidez estructural y evitan la deformaci\u00f3n durante el movimiento. En su periferia integra tres soportes elevados con huecos de montaje, los cuales permiten fijar servomotores de rotaci\u00f3n.</li> </ul> <ul> <li>Esta pieza funciona como v\u00ednculo mec\u00e1nico entre el servomotor y la base. Su forma alargada permite transmitir el movimiento generado por el servo hacia la estructura central. Cuenta con dos orificios de uni\u00f3n: uno con forma ovalada, que facilita el acoplamiento y reduce fricci\u00f3n con el eje del servo, y otro circular, destinado a la conexi\u00f3n mediante tornillo con la base.</li> </ul> <ul> <li>Esta pieza corresponde al brazo principal de soporte, encargado de conectar la parte superior del sistema con los servomotores. Su geometr\u00eda alargada proporciona mayor alcance y movimiento, permitiendo que la plataforma superior cambie de inclinaci\u00f3n. El brazo incluye dos orificios en los extremos, usados como puntos de articulaci\u00f3n con tornillos. Adem\u00e1s, cuenta con una ranura longitudinal, que facilita el montaje del tornillo.</li> </ul>"},{"location":"proyectofinal/#3-codigo","title":"3) C\u00f3digo \u2328\ufe0f","text":""},{"location":"proyectofinal/#codigo-python-visual-studio","title":"C\u00d3DIGO PYTHON (Visual Studio)","text":"<pre><code># ============================================================================\n# PLATAFORMA STEWART - CONTROL POR GESTOS DE MANO\n# ============================================================================\n# Este programa utiliza visi\u00f3n por computadora para detectar la posici\u00f3n\n# y orientaci\u00f3n de la mano del usuario, calculando \u00e1ngulos que se env\u00edan\n# a un ESP32 v\u00eda Bluetooth para controlar 3 servomotores en una plataforma\n# Stewart de 3 grados de libertad.\n# ============================================================================\n\n# ----- IMPORTACI\u00d3N DE LIBRER\u00cdAS -----\nimport cv2              # OpenCV: procesamiento de im\u00e1genes y captura de video\nimport mediapipe as mp  # MediaPipe: detecci\u00f3n de landmarks de la mano\nimport time             # Control de tiempos y delays\nimport bluetooth        # PyBluez: comunicaci\u00f3n Bluetooth con ESP32\n\n# ============================================================================\n# CONFIGURACI\u00d3N DE CONEXI\u00d3N BLUETOOTH\n# ============================================================================\n# El ESP32 act\u00faa como servidor Bluetooth Serial (SPP - Serial Port Profile)\n# La comunicaci\u00f3n se realiza en el puerto 1, que es el est\u00e1ndar para SPP\n\nPORT = 1                          # Puerto Bluetooth est\u00e1ndar para SPP\nESP32_MAC = \"14:33:5C:02:4D:2A\"   # Direcci\u00f3n MAC del ESP32 (CAMBIAR seg\u00fan tu dispositivo)\n\n# Creaci\u00f3n del socket Bluetooth tipo RFCOMM (comunicaci\u00f3n serial)\nsock = bluetooth.BluetoothSocket()\nsock.settimeout(20)  # Timeout de 20 segundos para evitar bloqueos indefinidos\n\n# ----- BUCLE DE CONEXI\u00d3N -----\n# Intenta conectar continuamente hasta lograr la conexi\u00f3n\n# Esto es \u00fatil cuando el ESP32 tarda en estar disponible\nprint(\"Intentando conectar al ESP32...\")\nwhile True:\n    try:\n        sock.connect((ESP32_MAC, PORT))  # Intenta establecer conexi\u00f3n\n        print(\"\u00a1Conectado al ESP32!\")\n        break  # Sale del bucle si la conexi\u00f3n es exitosa\n    except Exception as e:\n        print(\"Error en conexi\u00f3n... reintentando:\", e)\n        time.sleep(1)  # Espera 1 segundo antes de reintentar\n\n# ----- FUNCI\u00d3N DE ENV\u00cdO DE DATOS -----\ndef send_bt(message: str):\n    \"\"\"\n    Env\u00eda un mensaje codificado en UTF-8 al ESP32 v\u00eda Bluetooth.\n\n    Par\u00e1metros:\n        message (str): Cadena de texto a enviar (ej: \"ANG:90,90,90\\n\")\n\n    El mensaje se codifica a bytes antes de enviarse ya que Bluetooth\n    trabaja con datos binarios, no strings directamente.\n    \"\"\"\n    try:\n        sock.send(message.encode())       # Codifica string a bytes y env\u00eda\n        print(\"Enviado:\", message.strip()) # Muestra en consola (sin salto de l\u00ednea)\n    except:\n        print(\"Error enviando datos\")      # Manejo b\u00e1sico de errores\n\n# ============================================================================\n# CONFIGURACI\u00d3N DE MEDIAPIPE HANDS\n# ============================================================================\n# MediaPipe Hands es un modelo de ML que detecta 21 puntos (landmarks)\n# en la mano, permitiendo rastrear su posici\u00f3n y orientaci\u00f3n en tiempo real\n\nmp_hands = mp.solutions.hands  # M\u00f3dulo de detecci\u00f3n de manos\n\n# Inicializaci\u00f3n del detector de manos con par\u00e1metros optimizados\nhands = mp_hands.Hands(\n    max_num_hands=1,              # Solo detectar 1 mano (mejor rendimiento)\n    min_detection_confidence=0.6, # Confianza m\u00ednima para detectar mano (60%)\n    min_tracking_confidence=0.5   # Confianza m\u00ednima para rastrear (50%)\n)\n\n# Utilidades para dibujar los landmarks en la imagen\nmp_draw = mp.solutions.drawing_utils\n\n# ----- CAPTURA DE VIDEO -----\ncap = cv2.VideoCapture(0)  # Abre la c\u00e1mara por defecto (\u00edndice 0)\n\n# ============================================================================\n# VARIABLES DE FILTRADO Y CONTROL\n# ============================================================================\n# Los filtros suavizan el movimiento, eliminando tembladera y ruido\n# Se utiliza un filtro exponencial de primer orden (EMA)\n\npitch_filtrado = 0  # Valor filtrado de inclinaci\u00f3n arriba/abajo\nroll_filtrado = 0   # Valor filtrado de inclinaci\u00f3n izquierda/derecha\nalpha = 0.25        # Factor de suavizado (0.1=muy suave, 1.0=sin filtro)\n\n# Control de frecuencia de env\u00edo\nultimo_envio = time.time()  # Timestamp del \u00faltimo env\u00edo\nintervalo_envio = 0.05      # Enviar cada 50ms (20 Hz)\n\n# ============================================================================\n# POSICIONES HOME (NEUTRAS)\n# ============================================================================\n# Cuando la mano est\u00e1 en posici\u00f3n neutral, los servos van a estos \u00e1ngulos\n# 90\u00b0 es el centro del rango de movimiento de un servo (0\u00b0-180\u00b0)\n\nHOME_IZQ = 90     # Posici\u00f3n home del servo izquierdo (Pin 15)\nHOME_ARRIBA = 90  # Posici\u00f3n home del servo central (Pin 33)\nHOME_DER = 90     # Posici\u00f3n home del servo derecho (Pin 25)\n\n# ============================================================================\n# GANANCIAS DE CONTROL\n# ============================================================================\n# Estas constantes determinan qu\u00e9 tan sensible es cada movimiento\n# Valores m\u00e1s altos = movimientos m\u00e1s amplios de los servos\n\nK_pitch = 30.0       # Sensibilidad para inclinaci\u00f3n arriba/abajo\nK_roll = 0.05        # Sensibilidad para detecci\u00f3n de roll (pulgar)\nK_lat = 85.0         # Sensibilidad para movimiento lateral (izq/der)\nK_mid_acompa = 20.0  # Cu\u00e1nto acompa\u00f1a el servo central al movimiento lateral\n\n# ============================================================================\n# BUCLE PRINCIPAL DE PROCESAMIENTO\n# ============================================================================\n# Este bucle se ejecuta continuamente mientras la c\u00e1mara est\u00e9 abierta,\n# capturando frames, proces\u00e1ndolos y enviando comandos al ESP32\n\nwhile cap.isOpened():\n    # ----- CAPTURA DE FRAME -----\n    ret, img = cap.read()  # Lee un frame de la c\u00e1mara\n    if not ret:\n        break  # Sale si no puede leer (c\u00e1mara desconectada)\n\n    # Espeja la imagen horizontalmente para efecto espejo natural\n    # Esto hace que el movimiento de la mano corresponda intuitivamente\n    img = cv2.flip(img, 1)\n\n    # Convierte de BGR (formato OpenCV) a RGB (formato MediaPipe)\n    rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n\n    # ----- DETECCI\u00d3N DE MANO -----\n    results = hands.process(rgb)  # Procesa el frame con MediaPipe\n\n    h, w, _ = img.shape  # Obtiene dimensiones del frame (alto, ancho)\n    detectada = False    # Flag para saber si se detect\u00f3 mano\n\n    # ----- PROCESAMIENTO SI HAY MANO DETECTADA -----\n    if results.multi_hand_landmarks:\n        for hand in results.multi_hand_landmarks:\n            detectada = True\n\n            # Dibuja los 21 landmarks y sus conexiones en la imagen\n            mp_draw.draw_landmarks(img, hand, mp_hands.HAND_CONNECTIONS)\n\n            # ========== EXTRACCI\u00d3N DE LANDMARKS CLAVE ==========\n            # MediaPipe detecta 21 puntos en la mano, numerados del 0 al 20\n            # Usamos solo 3 puntos estrat\u00e9gicos:\n\n            muneca = hand.landmark[0]   # Punto 0: Mu\u00f1eca (base de la mano)\n            medio = hand.landmark[12]   # Punto 12: Punta del dedo medio\n            pulgar = hand.landmark[4]   # Punto 4: Punta del pulgar\n\n            # Convierte coordenadas normalizadas (0-1) a p\u00edxeles\n            # Las coordenadas de MediaPipe est\u00e1n normalizadas al tama\u00f1o de imagen\n            wx, wy = int(muneca.x * w), int(muneca.y * h)  # Mu\u00f1eca en p\u00edxeles\n            mx, my = int(medio.x * w), int(medio.y * h)    # Dedo medio en p\u00edxeles\n            px, py = int(pulgar.x * w), int(pulgar.y * h)  # Pulgar en p\u00edxeles\n\n            # Dibuja c\u00edrculos en los puntos clave para visualizaci\u00f3n\n            cv2.circle(img, (wx, wy), 10, (255, 0, 0), -1)  # Mu\u00f1eca: Azul\n            cv2.circle(img, (mx, my), 10, (0, 255, 0), -1)  # Medio: Verde\n            cv2.circle(img, (px, py), 10, (0, 0, 255), -1)  # Pulgar: Rojo\n\n            # ========== C\u00c1LCULO DE PITCH (ARRIBA/ABAJO) ==========\n            # El pitch se calcula usando la coordenada Z (profundidad)\n            # Cuando la mano se inclina hacia arriba, el dedo medio se acerca\n            # a la c\u00e1mara (Z menor) respecto a la mu\u00f1eca\n\n            pitch = (muneca.z - medio.z) * 1.8  # Diferencia de profundidad escalada\n            pitch = max(-1, min(1, pitch))       # Limita al rango [-1, 1]\n\n            # ========== C\u00c1LCULO DE ROLL (IZQUIERDA/DERECHA) ==========\n            # El roll se detecta por la posici\u00f3n vertical del pulgar\n            # Pulgar ARRIBA (py &lt; wy) = Roll positivo = Mover a DERECHA\n            # Pulgar ABAJO (py &gt; wy) = Roll negativo = Mover a IZQUIERDA\n\n            dy = wy - py              # Diferencia vertical (mu\u00f1eca - pulgar)\n            roll = dy * K_roll        # Escala la diferencia\n            roll = max(-1, min(1, roll))  # Limita al rango [-1, 1]\n\n            # ========== APLICACI\u00d3N DE FILTRO EXPONENCIAL ==========\n            # El filtro EMA (Exponential Moving Average) suaviza los valores\n            # F\u00f3rmula: valor_nuevo = (1-alpha)*valor_anterior + alpha*valor_actual\n            # Alpha bajo = m\u00e1s suave pero m\u00e1s lento\n            # Alpha alto = m\u00e1s r\u00e1pido pero m\u00e1s ruidoso\n\n            pitch_filtrado = (1 - alpha) * pitch_filtrado + alpha * pitch\n            roll_filtrado = (1 - alpha) * roll_filtrado + alpha * roll\n\n            # Zona muerta: ignora valores muy peque\u00f1os para evitar temblor\n            if abs(pitch_filtrado) &lt; 0.05:\n                pitch_filtrado = 0\n            if abs(roll_filtrado) &lt; 0.05:\n                roll_filtrado = 0\n\n            # ========== C\u00c1LCULO DE \u00c1NGULOS DE SERVOS ==========\n            # Cada servo se calcula bas\u00e1ndose en los valores filtrados\n            # La l\u00f3gica implementa el comportamiento de la plataforma Stewart\n\n            # ----- SERVO CENTRAL (ARRIBA - Pin 33) -----\n            # Sube con pitch positivo (mano hacia arriba)\n            # Tambi\u00e9n sube ligeramente cuando hay movimiento lateral\n            a_arriba = HOME_ARRIBA + K_pitch * pitch_filtrado + K_mid_acompa * abs(roll_filtrado)\n\n            # ----- SERVOS LATERALES (IZQ Pin 15, DER Pin 25) -----\n            # Calculamos el delta lateral basado en el roll\n            delta_lat = K_lat * roll_filtrado\n\n            # Izquierdo y derecho se mueven en direcciones opuestas\n            # Roll positivo (pulgar arriba/derecha): izq baja, der sube\n            # Roll negativo (pulgar abajo/izquierda): izq sube, der baja\n            a_izq = HOME_IZQ - delta_lat\n            a_der = HOME_DER + delta_lat\n\n            # Acompa\u00f1amiento de pitch en servos laterales\n            # Ambos bajan cuando la mano sube (pitch positivo)\n            a_izq += (K_pitch * 0.25) * pitch_filtrado\n            a_der += (K_pitch * 0.25) * pitch_filtrado\n\n            # Limita los \u00e1ngulos al rango v\u00e1lido de los servos (0\u00b0-180\u00b0)\n            a_izq = int(max(0, min(180, a_izq)))\n            a_arriba = int(max(0, min(180, a_arriba)))\n            a_der = int(max(0, min(180, a_der)))\n\n            # ========== ENV\u00cdO DE DATOS AL ESP32 ==========\n            # Solo env\u00eda si ha pasado suficiente tiempo desde el \u00faltimo env\u00edo\n            # Esto evita saturar la comunicaci\u00f3n Bluetooth\n\n            if time.time() - ultimo_envio &gt;= intervalo_envio:\n                # Formato del mensaje: \"ANG:izq,arriba,der\\n\"\n                msg = f\"ANG:{a_izq},{a_arriba},{a_der}\\n\"\n                send_bt(msg)\n                ultimo_envio = time.time()\n\n    # ----- MENSAJE CUANDO NO SE DETECTA MANO -----\n    if not detectada:\n        cv2.putText(img, \"No se detecta mano\", (10, 30),\n                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 0, 255), 2)\n\n    # ----- MOSTRAR IMAGEN EN VENTANA -----\n    cv2.imshow(\"STEWART CONTROL PULGAR\", img)\n\n    # ----- CONTROL DE TECLADO -----\n    k = cv2.waitKey(1)  # Espera 1ms por tecla\n\n    if k == ord('q'):      # Tecla 'q': Salir del programa\n        break\n    if k == ord('z') or k == ord('c'):  # Tecla 'z' o 'c': Enviar comando ZERO\n        send_bt(\"ZERO\\n\")   # Lleva todos los servos a posici\u00f3n home\n\n# ============================================================================\n# LIMPIEZA Y CIERRE\n# ============================================================================\n# Libera todos los recursos antes de terminar\n\nsock.close()              # Cierra la conexi\u00f3n Bluetooth\ncap.release()             # Libera la c\u00e1mara\ncv2.destroyAllWindows()   # Cierra todas las ventanas de OpenCV\nprint(\"Programa terminado\")\n</code></pre>"},{"location":"proyectofinal/#codigo-c-arduino","title":"C\u00d3DIGO C++ (ARDUINO)","text":"<pre><code>// ============================================================================\n// PLATAFORMA STEWART - FIRMWARE ESP32\n// ============================================================================\n\n#include &lt;Arduino.h&gt;           // Librer\u00eda base de Arduino\n#include \"BluetoothSerial.h\"   // Librer\u00eda para Bluetooth Classic (SPP)\n\n// Instancia del objeto Bluetooth Serial\nBluetoothSerial SerialBT;\n\n// Almacena caracteres recibidos hasta formar un comando completo (terminado en '\\n')\nString btBuffer;\n\n#define SERVO_IZQ    15   // GPIO 15: Servo izquierdo\n#define SERVO_ARRIBA 33   // GPIO 33: Servo central/vertical\n#define SERVO_DER    25   // GPIO 25: Servo derecho\n\n// ============================================================================\n// \u00c1NGULOS HOME (POSICI\u00d3N NEUTRAL)\n// ============================================================================\n// Cuando no hay comandos o se pierde la mano, los servos van a estos \u00e1ngulos\n// 90\u00b0 representa el centro del rango de movimiento\n\nconst int HOME_IZQ    = 90;   // Home servo izquierdo\nconst int HOME_ARRIBA = 90;   // Home servo central\nconst int HOME_DER    = 90;   // Home servo derecho\n\n// ============================================================================\n// CONFIGURACI\u00d3N PWM PARA SERVOS\n// ============================================================================\n// Los servos MG90S operan con se\u00f1ales PWM de 50Hz\n// El ancho del pulso determina la posici\u00f3n:\n// - ~1ms (5%) = 0\u00b0\n// - ~1.5ms (7.5%) = 90\u00b0\n// - ~2ms (10%) = 180\u00b0\n\nconst uint32_t FREQ_HZ   = 50;    // Frecuencia PWM: 50 Hz (per\u00edodo de 20ms)\nconst uint8_t  RES_BITS  = 12;    // Resoluci\u00f3n: 12 bits (0-4095)\nconst uint16_t DUTY_MIN  = 205;   // Duty cycle para 0\u00b0 (~1.0 ms)\nconst uint16_t DUTY_MAX  = 410;   // Duty cycle para 180\u00b0 (~2.0 ms)\n\n// ============================================================================\n// FUNCIONES DE CONVERSI\u00d3N DE \u00c1NGULOS\n// ============================================================================\n\n/**\n * Convierte grados (0-180) a valor de duty cycle para PWM\n * \n * @param deg \u00c1ngulo en grados (0-180)\n * @return Valor de duty cycle (205-410)\n * \n * La funci\u00f3n map() hace una interpolaci\u00f3n lineal:\n * 0\u00b0 -&gt; 205, 180\u00b0 -&gt; 410\n */\nuint16_t dutyFromDeg(int deg) {\n  deg = constrain(deg, 0, 180);                    // Limita al rango v\u00e1lido\n  return map(deg, 0, 180, DUTY_MIN, DUTY_MAX);     // Mapea a duty cycle\n}\n\n/**\n * Convierte \u00e1ngulo l\u00f3gico a f\u00edsico (inversi\u00f3n)\n * \n * @param logicalDeg \u00c1ngulo l\u00f3gico (0-180)\n * @return \u00c1ngulo f\u00edsico invertido (180-0)\n * \n * Esto es necesario porque los servos pueden estar montados\n * en direcci\u00f3n opuesta a la esperada. Invertir el \u00e1ngulo\n * hace que \"subir\" en el c\u00f3digo signifique \"subir\" f\u00edsicamente.\n */\nint logicalToPhysical(int logicalDeg) {\n  logicalDeg = constrain(logicalDeg, 0, 180);\n  return 180 - logicalDeg;  // Inversi\u00f3n: 0-&gt;180, 90-&gt;90, 180-&gt;0\n}\n\n/**\n * Escribe un \u00e1ngulo l\u00f3gico a un servo\n * \n * @param pin Pin GPIO del servo\n * @param logicalDeg \u00c1ngulo l\u00f3gico deseado (0-180)\n * \n * Convierte el \u00e1ngulo l\u00f3gico a f\u00edsico y luego a duty cycle\n * antes de escribir al pin PWM.\n */\nvoid writeServoLogical(int pin, int logicalDeg) {\n  int fisico = logicalToPhysical(logicalDeg);  // Convierte l\u00f3gico a f\u00edsico\n  ledcWrite(pin, dutyFromDeg(fisico));         // Escribe duty cycle al PWM\n}\n\n/**\n * Configura un pin GPIO como salida PWM para servo\n * \n * @param pin Pin GPIO a configurar\n * @param initialLogical \u00c1ngulo inicial en grados l\u00f3gicos\n * \n * En ESP32 Arduino Core 3.x, el pin act\u00faa como identificador del canal.\n * ledcAttach() configura autom\u00e1ticamente el canal PWM.\n */\nvoid configServo(int pin, int initialLogical) {\n  pinMode(pin, OUTPUT);                        // Configura pin como salida\n  ledcAttach(pin, FREQ_HZ, RES_BITS);          // Configura PWM: 50Hz, 12 bits\n  writeServoLogical(pin, initialLogical);      // Posiciona servo inicialmente\n}\n\n// ============================================================================\n// CONFIGURACI\u00d3N DE RAMPA (MOVIMIENTO SUAVE)\n// ============================================================================\n\nconst int  LIM_MIN     = 0;       // L\u00edmite m\u00ednimo de \u00e1ngulo\nconst int  LIM_MAX     = 180;     // L\u00edmite m\u00e1ximo de \u00e1ngulo\nconst int  PASO_RAMPA  = 5;       // Incremento por paso (grados)\nconst uint32_t DT_RAMP = 10;      // Intervalo entre pasos (ms)\nconst uint32_t TIMEOUT_MS = 700;  // Timeout para volver a home (ms)\n\n// ============================================================================\n// VARIABLES DE ESTADO\n// ============================================================================\n\n// Posiciones actuales de los servos (valores l\u00f3gicos)\nint posIzq    = HOME_IZQ;\nint posArriba = HOME_ARRIBA;\nint posDer    = HOME_DER;\n\n// Posiciones objetivo (hacia donde deben moverse)\nint tgtIzq    = HOME_IZQ;\nint tgtArriba = HOME_ARRIBA;\nint tgtDer    = HOME_DER;\n\n// Control de tiempo\nuint32_t tPrevRamp = 0;   // Timestamp del \u00faltimo paso de rampa\nuint32_t tLastCmd  = 0;   // Timestamp del \u00faltimo comando recibido\n\n// ============================================================================\n// FUNCI\u00d3N DE RAMPA SUAVE\n// ============================================================================\n/**\n * Aplica movimiento gradual hacia las posiciones objetivo\n * \n * Se ejecuta cada DT_RAMP milisegundos y mueve cada servo\n * un m\u00e1ximo de PASO_RAMPA grados hacia su objetivo.\n * Esto evita movimientos bruscos que podr\u00edan da\u00f1ar la mec\u00e1nica\n * o causar oscilaciones.\n */\nvoid aplicarRampa() {\n  uint32_t now = millis();\n\n  // Solo ejecuta si ha pasado suficiente tiempo\n  if (now - tPrevRamp &lt; DT_RAMP) return;\n  tPrevRamp = now;\n\n  // Lambda function para calcular siguiente posici\u00f3n\n  // Mueve hacia el target en pasos de PASO_RAMPA\n  auto go = [&amp;](int actual, int target) {\n    if (actual &lt; target) return min(actual + PASO_RAMPA, target);  // Subir\n    if (actual &gt; target) return max(actual - PASO_RAMPA, target);  // Bajar\n    return actual;  // Ya est\u00e1 en posici\u00f3n\n  };\n\n  // Actualiza posiciones actuales\n  posIzq    = go(posIzq,    tgtIzq);\n  posArriba = go(posArriba, tgtArriba);\n  posDer    = go(posDer,    tgtDer);\n\n  // Escribe las nuevas posiciones a los servos\n  writeServoLogical(SERVO_IZQ,    posIzq);\n  writeServoLogical(SERVO_ARRIBA, posArriba);\n  writeServoLogical(SERVO_DER,    posDer);\n}\n\n// ============================================================================\n// PARSER DE COMANDOS\n// ============================================================================\n/**\n * Parsea un mensaje de \u00e1ngulos en formato \"ANG:x,y,z\"\n * \n * @param msg Mensaje recibido (ej: \"ANG:45,90,135\")\n * @param aIzq Variable donde se guarda \u00e1ngulo izquierdo\n * @param aArriba Variable donde se guarda \u00e1ngulo central\n * @param aDer Variable donde se guarda \u00e1ngulo derecho\n * @return true si el parseo fue exitoso, false si el formato es inv\u00e1lido\n */\nbool parseAngulos(const String &amp;msg, int &amp;aIzq, int &amp;aArriba, int &amp;aDer) {\n  // Verifica que el mensaje comience con \"ANG:\"\n  if (!msg.startsWith(\"ANG:\")) return false;\n\n  // Extrae la parte de datos (despu\u00e9s de \"ANG:\")\n  String data = msg.substring(4);\n\n  // Busca las comas que separan los valores\n  int c1 = data.indexOf(',');          // Primera coma\n  int c2 = data.indexOf(',', c1 + 1);  // Segunda coma\n\n  // Verifica que existan ambas comas\n  if (c1 &lt; 0 || c2 &lt; 0) return false;\n\n  // Extrae y convierte cada valor\n  aIzq    = data.substring(0, c1).toInt();      // Primer n\u00famero\n  aArriba = data.substring(c1 + 1, c2).toInt(); // Segundo n\u00famero\n  aDer    = data.substring(c2 + 1).toInt();     // Tercer n\u00famero\n\n  return true;\n}\n\n// ============================================================================\n// FUNCI\u00d3N SETUP - INICIALIZACI\u00d3N\n// ============================================================================\n/**\n * Se ejecuta una vez al encender/reiniciar el ESP32\n * Configura la comunicaci\u00f3n serial, Bluetooth y los servos\n */\nvoid setup() {\n  // Inicializa comunicaci\u00f3n serial para debug (USB)\n  Serial.begin(115200);\n\n  // Inicializa Bluetooth con nombre visible \"ESP32-Stewart\"\n  SerialBT.begin(\"ESP32-Stewart\");\n\n  // Configura los 3 servos con sus posiciones home\n  configServo(SERVO_IZQ,    posIzq);\n  configServo(SERVO_ARRIBA, posArriba);\n  configServo(SERVO_DER,    posDer);\n\n  // Mensajes de informaci\u00f3n en Serial Monitor\n  Serial.println(\"ESP32 listo - Plataforma Stewart\");\n  Serial.println(\"Pines: 15 = Izq, 33 = Arriba, 25 = Der\");\n\n  // Inicializa timestamp del \u00faltimo comando\n  tLastCmd = millis();\n}\n\n// ============================================================================\n// FUNCI\u00d3N LOOP - BUCLE PRINCIPAL\n// ============================================================================\n/**\n * Se ejecuta continuamente despu\u00e9s del setup\n * Lee comandos Bluetooth, los procesa y actualiza los servos\n */\nvoid loop() {\n\n  // ========== LECTURA DE BLUETOOTH ==========\n  // Lee caracteres disponibles y los acumula en el buffer\n  while (SerialBT.available()) {\n    char c = (char)SerialBT.read();  // Lee un caracter\n\n    if (c == '\\n') {\n      // ----- FIN DE L\u00cdNEA: PROCESAR COMANDO -----\n      String msg = btBuffer;  // Copia el buffer\n      btBuffer = \"\";          // Limpia el buffer para el pr\u00f3ximo mensaje\n      msg.trim();             // Elimina espacios y saltos de l\u00ednea\n\n      if (msg.length() &gt; 0) {\n        tLastCmd = millis();  // Actualiza timestamp del \u00faltimo comando\n\n        // ----- COMANDO ZERO O LOST -----\n        // Enviados cuando se pierde la mano o se presiona 'z'\n        if (msg == \"ZERO\" || msg == \"LOST\") {\n          tgtIzq    = HOME_IZQ;\n          tgtArriba = HOME_ARRIBA;\n          tgtDer    = HOME_DER;\n          Serial.println(\"HOME ejecutado (ZERO/LOST)\");\n        }\n        // ----- COMANDO DE \u00c1NGULOS -----\n        else {\n          int aI, aA, aD;\n          if (parseAngulos(msg, aI, aA, aD)) {\n            // Parseo exitoso: actualiza objetivos con l\u00edmites\n            tgtIzq    = constrain(aI, LIM_MIN, LIM_MAX);\n            tgtArriba = constrain(aA, LIM_MIN, LIM_MAX);\n            tgtDer    = constrain(aD, LIM_MIN, LIM_MAX);\n            Serial.printf(\"ANG -&gt; %d, %d, %d\\n\", tgtIzq, tgtArriba, tgtDer);\n          }\n          else {\n            // Comando no reconocido\n            Serial.print(\"Comando desconocido: \");\n            Serial.println(msg);\n          }\n        }\n      }\n    }\n    else if (c != '\\r') {\n      // Acumula caracteres (ignora retorno de carro)\n      btBuffer += c;\n    }\n  }\n\n  // ========== TIMEOUT: RETORNO A HOME ==========\n  // Si no se reciben comandos por TIMEOUT_MS, vuelve a posici\u00f3n home\n  // Esto es una medida de seguridad por si se pierde la conexi\u00f3n\n  if (millis() - tLastCmd &gt; TIMEOUT_MS) {\n    tgtIzq    = HOME_IZQ;\n    tgtArriba = HOME_ARRIBA;\n    tgtDer    = HOME_DER;\n  }\n\n  // ========== APLICAR RAMPA ==========\n  // Mueve los servos suavemente hacia sus objetivos\n  aplicarRampa();\n  // Peque\u00f1o delay para estabilidad\n  delay(1);\n}\n</code></pre>"}]}